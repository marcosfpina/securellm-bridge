# Hooks Configuration Reference
# Complete example showing all available hook options and metadata

repos:
  - name: example-repo
    path: "./example"
    priority: medium
    description: "Example repository with all hook features"

    context: |
      This is a reference implementation showing all possible
      hook configurations and metadata options.

    # Hook Stages: pre_analyze, post_analyze
    hooks:
      # PRE-ANALYZE HOOKS
      # Executed before code analysis begins
      pre_analyze:
        # Minimal hook (only required fields)
        - description: "Simple validation"
          command: "echo 'Starting analysis...'"

        # Hook with failure handling
        - description: "Optional dependency check"
          command: "which some-optional-tool"
          allow_failure: true

        # Hook with custom timeout
        - description: "Long-running setup"
          command: "poetry install --no-interaction"
          timeout: 600  # 10 minutes
          allow_failure: false

        # Hook with retry capability
        - description: "Network-dependent operation"
          command: "curl -f https://api.example.com/health"
          retry: true
          timeout: 30
          allow_failure: true

        # Complex hook with all options
        - description: "Full-featured pre-analysis validation"
          command: |
            set -e
            echo "Running comprehensive checks..."
            poetry check
            ruff check src/
            mypy src/ --no-error-summary
          timeout: 180
          retry: false
          allow_failure: false

      # POST-ANALYZE HOOKS
      # Executed after code analysis completes
      post_analyze:
        # Test execution
        - description: "Run unit tests"
          command: "pytest tests/unit/ -v --tb=short"
          timeout: 300
          allow_failure: false
          retry: false

        # Integration tests (allowed to fail)
        - description: "Run integration tests (best effort)"
          command: "pytest tests/integration/ -v"
          timeout: 600
          allow_failure: true
          retry: true

        # Code quality checks
        - description: "Check code coverage"
          command: "pytest --cov=src --cov-report=term-missing --cov-fail-under=80"
          timeout: 300
          allow_failure: true

        # Security scanning
        - description: "Security vulnerability scan"
          command: "safety check --json || true"
          timeout: 60
          allow_failure: true

        # Dependency auditing
        - description: "Audit dependencies"
          command: "pip-audit --desc"
          timeout: 120
          allow_failure: true

        # Generate reports
        - description: "Generate analysis report"
          command: "phantom knowledge summarize example-repo"
          timeout: 30
          allow_failure: false

        # Notification hook
        - description: "Send completion notification"
          command: |
            curl -X POST https://hooks.slack.com/services/YOUR/WEBHOOK/URL \
              -H 'Content-Type: application/json' \
              -d '{"text": "Analysis complete for example-repo"}'
          timeout: 10
          allow_failure: true

    options:
      deep_analysis: true
      extract_ast: true
      security_scan: true
      performance_analysis: true
      languages: ["python", "nix", "rust", "bash"]

# ============================================================
# HOOK METADATA REFERENCE
# ============================================================

# description: string (REQUIRED)
#   Human-readable description of what the hook does
#   Used in logs and reports
#   Example: "Validate project structure"

# command: string (REQUIRED)
#   Shell command to execute
#   Can be multi-line using YAML literal style (|)
#   Executed in repository root directory
#   Example: "poetry check"

# allow_failure: boolean (OPTIONAL, default: false)
#   If true, hook failure won't stop the analysis pipeline
#   Use for non-critical operations
#   Example: true

# timeout: integer (OPTIONAL, default: 120)
#   Maximum execution time in seconds
#   Hook will be killed if timeout is reached
#   Example: 300

# retry: boolean (OPTIONAL, default: false)
#   If true, retry once on failure
#   Useful for network-dependent operations
#   Only retries once (max 2 attempts total)
#   Example: true

# ============================================================
# HOOK BEST PRACTICES
# ============================================================

# 1. ALWAYS provide clear descriptions
#    Bad:  "Run command"
#    Good: "Validate project dependencies with poetry"

# 2. Set appropriate timeouts
#    - Quick checks: 30-60s
#    - Tests: 300-600s
#    - Builds: 600-1800s

# 3. Use allow_failure wisely
#    - Critical: allow_failure: false (default)
#    - Optional: allow_failure: true
#    - Nice-to-have: allow_failure: true

# 4. Only use retry for idempotent operations
#    - Network requests: retry: true
#    - File operations: retry: false
#    - Tests: retry: false

# 5. Keep commands focused
#    - One hook = one purpose
#    - Chain related commands with && in single hook
#    - Don't mix concerns (testing + reporting = separate hooks)

# 6. Handle errors gracefully in commands
#    - Use `|| true` to force success if needed
#    - Use `set -e` to fail fast on errors
#    - Capture and log errors appropriately

# 7. Consider execution order
#    - Hooks execute in definition order
#    - Put fast checks before slow ones
#    - Put critical checks before optional ones

# ============================================================
# COMMON HOOK PATTERNS
# ============================================================

# Pattern 1: Cleanup
# hooks:
#   pre_analyze:
#     - description: "Clean previous artifacts"
#       command: "rm -rf ./data/analyzed/{{repo_name}}"
#       allow_failure: true

# Pattern 2: Environment Validation
# hooks:
#   pre_analyze:
#     - description: "Validate environment"
#       command: |
#         command -v poetry >/dev/null || exit 1
#         poetry check
#       timeout: 60

# Pattern 3: Multi-stage Testing
# hooks:
#   post_analyze:
#     - description: "Unit tests"
#       command: "pytest tests/unit/"
#     - description: "Integration tests"
#       command: "pytest tests/integration/"
#       allow_failure: true

# Pattern 4: Conditional Execution
# hooks:
#   pre_analyze:
#     - description: "Run pre-commit if available"
#       command: "which pre-commit && pre-commit run --all-files || true"
#       allow_failure: true

# Pattern 5: Parallel-safe Operations
# hooks:
#   post_analyze:
#     - description: "Generate report"
#       command: "phantom knowledge summarize {{repo_name}}"
#     - description: "Archive results"
#       command: "tar -czf results-$(date +%Y%m%d).tar.gz data/analyzed/{{repo_name}}"
#       allow_failure: true
